/**
 * generated by Xtext 2.19.0
 */
package com.simonbaars.cdd.validation;

import com.google.common.base.Objects;
import com.simonbaars.cdd.cloneDetectionDSL.Compare;
import com.simonbaars.cdd.cloneDetectionDSL.Method;
import com.simonbaars.cdd.cloneDetectionDSL.Node;
import com.simonbaars.cdd.validation.AbstractCloneDetectionDSLValidator;
import java.util.Collections;
import java.util.List;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Exceptions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class CloneDetectionDSLValidator extends AbstractCloneDetectionDSLValidator {
  private static final String root = "com.github.javaparser.ast.";
  
  private static final List<String> packages = Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList("body", "expr", "stmt", "type"));
  
  @Check
  public void checkCompare(final Compare compare) {
    if (((Objects.equal(compare.getComparisonMethod(), Method.FQI) || Objects.equal(compare.getComparisonMethod(), Method.COMPLETE_MATCH)) || Objects.equal(compare.getComparisonMethod(), Method.STRING_MATCH))) {
      Node _deepestNode = compare.getDeepestNode();
      boolean _tripleNotEquals = (_deepestNode != null);
      if (_tripleNotEquals) {
        Method _comparisonMethod = compare.getComparisonMethod();
        String _plus = ("Node option is not allowed for comparison method " + _comparisonMethod);
        String _plus_1 = (_plus + " and is thus ignored!");
        this.warning(_plus_1, null);
      }
    }
    if ((Objects.equal(compare.getComparisonMethod(), Method.FQI) || Objects.equal(compare.getComparisonMethod(), Method.COMPLETE_MATCH))) {
      String _perc = compare.getPerc();
      boolean _tripleNotEquals_1 = (_perc != null);
      if (_tripleNotEquals_1) {
        Method _comparisonMethod_1 = compare.getComparisonMethod();
        String _plus_2 = ("Similarity percentage option is not allowed for comparison method " + _comparisonMethod_1);
        String _plus_3 = (_plus_2 + " and is thus ignored!");
        this.warning(_plus_3, null);
      }
    }
    Method _comparisonMethod_2 = compare.getComparisonMethod();
    boolean _equals = Objects.equal(_comparisonMethod_2, Method.STRING_MATCH);
    if (_equals) {
      String _perc_1 = compare.getPerc();
      boolean _tripleEquals = (_perc_1 == null);
      if (_tripleEquals) {
        this.error("Similarity percentage must be specified for string comparison!", null);
      }
    }
    Method _comparisonMethod_3 = compare.getComparisonMethod();
    boolean _equals_1 = Objects.equal(_comparisonMethod_3, Method.SUBNODES);
    if (_equals_1) {
      String _perc_2 = compare.getPerc();
      boolean _tripleEquals_1 = (_perc_2 == null);
      if (_tripleEquals_1) {
        this.error("Similarity percentage must be specified for subtree comparison!", null);
      }
    }
  }
  
  public void checkNode(final Node node) {
    try {
      String _name = node.getName();
      String _plus = (CloneDetectionDSLValidator.root + _name);
      Class.forName(_plus);
      return;
    } catch (final Throwable _t) {
      if (_t instanceof ClassNotFoundException) {
        for (final String pack : CloneDetectionDSLValidator.packages) {
          try {
            String _name_1 = node.getName();
            String _plus_1 = (((CloneDetectionDSLValidator.root + pack) + ".") + _name_1);
            Class.forName(_plus_1);
            return;
          } catch (final Throwable _t_1) {
            if (_t_1 instanceof ClassNotFoundException) {
            } else {
              throw Exceptions.sneakyThrow(_t_1);
            }
          }
        }
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    this.error("This is not a correct node type!", null);
  }
}
