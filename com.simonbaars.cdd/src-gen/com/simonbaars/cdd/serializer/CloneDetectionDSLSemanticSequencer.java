/*
 * generated by Xtext 2.19.0
 */
package com.simonbaars.cdd.serializer;

import com.google.inject.Inject;
import com.simonbaars.cdd.cloneDetectionDSL.BooleanExpressionBracket;
import com.simonbaars.cdd.cloneDetectionDSL.BooleanExpressionConstant;
import com.simonbaars.cdd.cloneDetectionDSL.CloneDetection;
import com.simonbaars.cdd.cloneDetectionDSL.CloneDetectionDSLPackage;
import com.simonbaars.cdd.cloneDetectionDSL.Compare;
import com.simonbaars.cdd.cloneDetectionDSL.ExpressionAddition;
import com.simonbaars.cdd.cloneDetectionDSL.ExpressionBinOp;
import com.simonbaars.cdd.cloneDetectionDSL.ExpressionBracket;
import com.simonbaars.cdd.cloneDetectionDSL.ExpressionCompOp;
import com.simonbaars.cdd.cloneDetectionDSL.ExpressionConstantInt;
import com.simonbaars.cdd.cloneDetectionDSL.ExpressionDivision;
import com.simonbaars.cdd.cloneDetectionDSL.ExpressionMaximum;
import com.simonbaars.cdd.cloneDetectionDSL.ExpressionMinimum;
import com.simonbaars.cdd.cloneDetectionDSL.ExpressionMinus;
import com.simonbaars.cdd.cloneDetectionDSL.ExpressionModulo;
import com.simonbaars.cdd.cloneDetectionDSL.ExpressionMultiply;
import com.simonbaars.cdd.cloneDetectionDSL.ExpressionPlus;
import com.simonbaars.cdd.cloneDetectionDSL.ExpressionPower;
import com.simonbaars.cdd.cloneDetectionDSL.ExpressionSubtraction;
import com.simonbaars.cdd.cloneDetectionDSL.IntExpression;
import com.simonbaars.cdd.cloneDetectionDSL.Match;
import com.simonbaars.cdd.cloneDetectionDSL.MetricExpr;
import com.simonbaars.cdd.cloneDetectionDSL.MinSize;
import com.simonbaars.cdd.cloneDetectionDSL.Node;
import com.simonbaars.cdd.cloneDetectionDSL.Nodes;
import com.simonbaars.cdd.cloneDetectionDSL.NotExpression;
import com.simonbaars.cdd.cloneDetectionDSL.Project;
import com.simonbaars.cdd.cloneDetectionDSL.SearchRoot;
import com.simonbaars.cdd.services.CloneDetectionDSLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CloneDetectionDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CloneDetectionDSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CloneDetectionDSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CloneDetectionDSLPackage.BOOLEAN_EXPRESSION_BRACKET:
				sequence_BooleanExpressionBracket(context, (BooleanExpressionBracket) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.BOOLEAN_EXPRESSION_CONSTANT:
				sequence_BooleanExpressionConstant(context, (BooleanExpressionConstant) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.CLONE_DETECTION:
				sequence_CloneDetection(context, (CloneDetection) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.COMPARE:
				sequence_Compare(context, (Compare) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.EXPRESSION_ADDITION:
				sequence_ExpressionLevel1(context, (ExpressionAddition) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.EXPRESSION_BIN_OP:
				sequence_BooleanExpressionLevel1(context, (ExpressionBinOp) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.EXPRESSION_BRACKET:
				sequence_ExpressionBracket(context, (ExpressionBracket) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.EXPRESSION_COMP_OP:
				sequence_ComparisonExpression(context, (ExpressionCompOp) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.EXPRESSION_CONSTANT_INT:
				sequence_ExpressionConstantInt(context, (ExpressionConstantInt) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.EXPRESSION_DIVISION:
				sequence_ExpressionLevel2(context, (ExpressionDivision) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.EXPRESSION_MAXIMUM:
				sequence_ExpressionLevel2(context, (ExpressionMaximum) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.EXPRESSION_MINIMUM:
				sequence_ExpressionLevel2(context, (ExpressionMinimum) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.EXPRESSION_MINUS:
				sequence_ExpressionMinus(context, (ExpressionMinus) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.EXPRESSION_MODULO:
				sequence_ExpressionLevel2(context, (ExpressionModulo) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.EXPRESSION_MULTIPLY:
				sequence_ExpressionLevel2(context, (ExpressionMultiply) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.EXPRESSION_PLUS:
				sequence_ExpressionPlus(context, (ExpressionPlus) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.EXPRESSION_POWER:
				sequence_ExpressionLevel3(context, (ExpressionPower) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.EXPRESSION_SUBTRACTION:
				sequence_ExpressionLevel1(context, (ExpressionSubtraction) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.INT_EXPRESSION:
				sequence_ExpressionLevel5(context, (IntExpression) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.MATCH:
				sequence_Match(context, (Match) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.METRIC_EXPR:
				sequence_MetricExpr(context, (MetricExpr) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.MIN_SIZE:
				sequence_MinSize(context, (MinSize) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.NODES:
				sequence_Nodes(context, (Nodes) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.NOT_EXPRESSION:
				sequence_NotExpression(context, (NotExpression) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.PROJECT:
				sequence_Project(context, (Project) semanticObject); 
				return; 
			case CloneDetectionDSLPackage.SEARCH_ROOT:
				sequence_SearchRoot(context, (SearchRoot) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     BooleanExpression returns BooleanExpressionBracket
	 *     BooleanExpressionLevel1 returns BooleanExpressionBracket
	 *     BooleanExpressionLevel1.ExpressionBinOp_1_0 returns BooleanExpressionBracket
	 *     BooleanExpressionLevel2 returns BooleanExpressionBracket
	 *     BooleanExpressionLevel3 returns BooleanExpressionBracket
	 *     BooleanExpressionBracket returns BooleanExpressionBracket
	 *
	 * Constraint:
	 *     sub=BooleanExpression
	 */
	protected void sequence_BooleanExpressionBracket(ISerializationContext context, BooleanExpressionBracket semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.BOOLEAN_EXPRESSION_BRACKET__SUB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.BOOLEAN_EXPRESSION_BRACKET__SUB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanExpressionBracketAccess().getSubBooleanExpressionParserRuleCall_1_0(), semanticObject.getSub());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns BooleanExpressionConstant
	 *     BooleanExpressionLevel1 returns BooleanExpressionConstant
	 *     BooleanExpressionLevel1.ExpressionBinOp_1_0 returns BooleanExpressionConstant
	 *     BooleanExpressionLevel2 returns BooleanExpressionConstant
	 *     BooleanExpressionLevel3 returns BooleanExpressionConstant
	 *     BooleanExpressionConstant returns BooleanExpressionConstant
	 *
	 * Constraint:
	 *     value=BOOL_LITERAL
	 */
	protected void sequence_BooleanExpressionConstant(ISerializationContext context, BooleanExpressionConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.BOOLEAN_EXPRESSION_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.BOOLEAN_EXPRESSION_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanExpressionConstantAccess().getValueBOOL_LITERALTerminalRuleCall_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns ExpressionBinOp
	 *     BooleanExpressionLevel1 returns ExpressionBinOp
	 *     BooleanExpressionLevel1.ExpressionBinOp_1_0 returns ExpressionBinOp
	 *
	 * Constraint:
	 *     (left=BooleanExpressionLevel1_ExpressionBinOp_1_0 bop=BinaryBooleanOperator right=BooleanExpressionLevel2)
	 */
	protected void sequence_BooleanExpressionLevel1(ISerializationContext context, ExpressionBinOp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_BIN_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_BIN_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_BIN_OP__BOP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_BIN_OP__BOP));
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_BIN_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_BIN_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanExpressionLevel1Access().getExpressionBinOpLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBooleanExpressionLevel1Access().getBopBinaryBooleanOperatorEnumRuleCall_1_1_0(), semanticObject.getBop());
		feeder.accept(grammarAccess.getBooleanExpressionLevel1Access().getRightBooleanExpressionLevel2ParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CloneDetection returns CloneDetection
	 *
	 * Constraint:
	 *     (
	 *         project=Project | 
	 *         root?=SearchRoot | 
	 *         match?=Match | 
	 *         exclude?=Exclude | 
	 *         size=MinSize | 
	 *         notCompare+=DoNotCompare | 
	 *         compare+=Compare
	 *     )+
	 */
	protected void sequence_CloneDetection(ISerializationContext context, CloneDetection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Compare returns Compare
	 *
	 * Constraint:
	 *     (nodes=Nodes comparisonMethod=Method deepestNode=Node? perc=Percentage?)
	 */
	protected void sequence_Compare(ISerializationContext context, Compare semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns ExpressionCompOp
	 *     BooleanExpressionLevel1 returns ExpressionCompOp
	 *     BooleanExpressionLevel1.ExpressionBinOp_1_0 returns ExpressionCompOp
	 *     BooleanExpressionLevel2 returns ExpressionCompOp
	 *     BooleanExpressionLevel3 returns ExpressionCompOp
	 *     ComparisonExpression returns ExpressionCompOp
	 *
	 * Constraint:
	 *     (left=IntExpression op=CompareOperator right=IntExpression)
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, ExpressionCompOp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_COMP_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_COMP_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_COMP_OP__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_COMP_OP__OP));
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_COMP_OP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_COMP_OP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getLeftIntExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getOpCompareOperatorEnumRuleCall_2_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getRightIntExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns ExpressionBracket
	 *     ExpressionLevel1 returns ExpressionBracket
	 *     ExpressionLevel1.ExpressionAddition_1_0_0 returns ExpressionBracket
	 *     ExpressionLevel1.ExpressionSubtraction_1_1_0 returns ExpressionBracket
	 *     ExpressionLevel2 returns ExpressionBracket
	 *     ExpressionLevel2.ExpressionMultiply_1_0_0 returns ExpressionBracket
	 *     ExpressionLevel2.ExpressionDivision_1_1_0 returns ExpressionBracket
	 *     ExpressionLevel2.ExpressionMaximum_1_2_0 returns ExpressionBracket
	 *     ExpressionLevel2.ExpressionMinimum_1_3_0 returns ExpressionBracket
	 *     ExpressionLevel2.ExpressionModulo_1_4_0 returns ExpressionBracket
	 *     ExpressionLevel3 returns ExpressionBracket
	 *     ExpressionLevel3.ExpressionPower_1_0 returns ExpressionBracket
	 *     ExpressionLevel4 returns ExpressionBracket
	 *     ExpressionLevel5 returns ExpressionBracket
	 *     ExpressionBracket returns ExpressionBracket
	 *
	 * Constraint:
	 *     sub=IntExpression
	 */
	protected void sequence_ExpressionBracket(ISerializationContext context, ExpressionBracket semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_BRACKET__SUB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_BRACKET__SUB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionBracketAccess().getSubIntExpressionParserRuleCall_1_0(), semanticObject.getSub());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns ExpressionConstantInt
	 *     ExpressionLevel1 returns ExpressionConstantInt
	 *     ExpressionLevel1.ExpressionAddition_1_0_0 returns ExpressionConstantInt
	 *     ExpressionLevel1.ExpressionSubtraction_1_1_0 returns ExpressionConstantInt
	 *     ExpressionLevel2 returns ExpressionConstantInt
	 *     ExpressionLevel2.ExpressionMultiply_1_0_0 returns ExpressionConstantInt
	 *     ExpressionLevel2.ExpressionDivision_1_1_0 returns ExpressionConstantInt
	 *     ExpressionLevel2.ExpressionMaximum_1_2_0 returns ExpressionConstantInt
	 *     ExpressionLevel2.ExpressionMinimum_1_3_0 returns ExpressionConstantInt
	 *     ExpressionLevel2.ExpressionModulo_1_4_0 returns ExpressionConstantInt
	 *     ExpressionLevel3 returns ExpressionConstantInt
	 *     ExpressionLevel3.ExpressionPower_1_0 returns ExpressionConstantInt
	 *     ExpressionLevel4 returns ExpressionConstantInt
	 *     ExpressionLevel5 returns ExpressionConstantInt
	 *     ExpressionConstantInt returns ExpressionConstantInt
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_ExpressionConstantInt(ISerializationContext context, ExpressionConstantInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_CONSTANT_INT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_CONSTANT_INT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionConstantIntAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns ExpressionAddition
	 *     ExpressionLevel1 returns ExpressionAddition
	 *     ExpressionLevel1.ExpressionAddition_1_0_0 returns ExpressionAddition
	 *     ExpressionLevel1.ExpressionSubtraction_1_1_0 returns ExpressionAddition
	 *
	 * Constraint:
	 *     (left=ExpressionLevel1_ExpressionAddition_1_0_0 right=ExpressionLevel2)
	 */
	protected void sequence_ExpressionLevel1(ISerializationContext context, ExpressionAddition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_ADDITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_ADDITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_ADDITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_ADDITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel1Access().getExpressionAdditionLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel1Access().getRightExpressionLevel2ParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns ExpressionSubtraction
	 *     ExpressionLevel1 returns ExpressionSubtraction
	 *     ExpressionLevel1.ExpressionAddition_1_0_0 returns ExpressionSubtraction
	 *     ExpressionLevel1.ExpressionSubtraction_1_1_0 returns ExpressionSubtraction
	 *
	 * Constraint:
	 *     (left=ExpressionLevel1_ExpressionSubtraction_1_1_0 right=ExpressionLevel2)
	 */
	protected void sequence_ExpressionLevel1(ISerializationContext context, ExpressionSubtraction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_SUBTRACTION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_SUBTRACTION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_SUBTRACTION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_SUBTRACTION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel1Access().getExpressionSubtractionLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel1Access().getRightExpressionLevel2ParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns ExpressionDivision
	 *     ExpressionLevel1 returns ExpressionDivision
	 *     ExpressionLevel1.ExpressionAddition_1_0_0 returns ExpressionDivision
	 *     ExpressionLevel1.ExpressionSubtraction_1_1_0 returns ExpressionDivision
	 *     ExpressionLevel2 returns ExpressionDivision
	 *     ExpressionLevel2.ExpressionMultiply_1_0_0 returns ExpressionDivision
	 *     ExpressionLevel2.ExpressionDivision_1_1_0 returns ExpressionDivision
	 *     ExpressionLevel2.ExpressionMaximum_1_2_0 returns ExpressionDivision
	 *     ExpressionLevel2.ExpressionMinimum_1_3_0 returns ExpressionDivision
	 *     ExpressionLevel2.ExpressionModulo_1_4_0 returns ExpressionDivision
	 *
	 * Constraint:
	 *     (left=ExpressionLevel2_ExpressionDivision_1_1_0 right=ExpressionLevel3)
	 */
	protected void sequence_ExpressionLevel2(ISerializationContext context, ExpressionDivision semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_DIVISION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_DIVISION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_DIVISION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_DIVISION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel2Access().getExpressionDivisionLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel2Access().getRightExpressionLevel3ParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns ExpressionMaximum
	 *     ExpressionLevel1 returns ExpressionMaximum
	 *     ExpressionLevel1.ExpressionAddition_1_0_0 returns ExpressionMaximum
	 *     ExpressionLevel1.ExpressionSubtraction_1_1_0 returns ExpressionMaximum
	 *     ExpressionLevel2 returns ExpressionMaximum
	 *     ExpressionLevel2.ExpressionMultiply_1_0_0 returns ExpressionMaximum
	 *     ExpressionLevel2.ExpressionDivision_1_1_0 returns ExpressionMaximum
	 *     ExpressionLevel2.ExpressionMaximum_1_2_0 returns ExpressionMaximum
	 *     ExpressionLevel2.ExpressionMinimum_1_3_0 returns ExpressionMaximum
	 *     ExpressionLevel2.ExpressionModulo_1_4_0 returns ExpressionMaximum
	 *
	 * Constraint:
	 *     (left=ExpressionLevel2_ExpressionMaximum_1_2_0 right=ExpressionLevel3)
	 */
	protected void sequence_ExpressionLevel2(ISerializationContext context, ExpressionMaximum semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MAXIMUM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MAXIMUM__LEFT));
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MAXIMUM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MAXIMUM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel2Access().getExpressionMaximumLeftAction_1_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel2Access().getRightExpressionLevel3ParserRuleCall_1_2_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns ExpressionMinimum
	 *     ExpressionLevel1 returns ExpressionMinimum
	 *     ExpressionLevel1.ExpressionAddition_1_0_0 returns ExpressionMinimum
	 *     ExpressionLevel1.ExpressionSubtraction_1_1_0 returns ExpressionMinimum
	 *     ExpressionLevel2 returns ExpressionMinimum
	 *     ExpressionLevel2.ExpressionMultiply_1_0_0 returns ExpressionMinimum
	 *     ExpressionLevel2.ExpressionDivision_1_1_0 returns ExpressionMinimum
	 *     ExpressionLevel2.ExpressionMaximum_1_2_0 returns ExpressionMinimum
	 *     ExpressionLevel2.ExpressionMinimum_1_3_0 returns ExpressionMinimum
	 *     ExpressionLevel2.ExpressionModulo_1_4_0 returns ExpressionMinimum
	 *
	 * Constraint:
	 *     (left=ExpressionLevel2_ExpressionMinimum_1_3_0 right=ExpressionLevel3)
	 */
	protected void sequence_ExpressionLevel2(ISerializationContext context, ExpressionMinimum semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MINIMUM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MINIMUM__LEFT));
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MINIMUM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MINIMUM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel2Access().getExpressionMinimumLeftAction_1_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel2Access().getRightExpressionLevel3ParserRuleCall_1_3_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns ExpressionModulo
	 *     ExpressionLevel1 returns ExpressionModulo
	 *     ExpressionLevel1.ExpressionAddition_1_0_0 returns ExpressionModulo
	 *     ExpressionLevel1.ExpressionSubtraction_1_1_0 returns ExpressionModulo
	 *     ExpressionLevel2 returns ExpressionModulo
	 *     ExpressionLevel2.ExpressionMultiply_1_0_0 returns ExpressionModulo
	 *     ExpressionLevel2.ExpressionDivision_1_1_0 returns ExpressionModulo
	 *     ExpressionLevel2.ExpressionMaximum_1_2_0 returns ExpressionModulo
	 *     ExpressionLevel2.ExpressionMinimum_1_3_0 returns ExpressionModulo
	 *     ExpressionLevel2.ExpressionModulo_1_4_0 returns ExpressionModulo
	 *
	 * Constraint:
	 *     (left=ExpressionLevel2_ExpressionModulo_1_4_0 right=ExpressionLevel3)
	 */
	protected void sequence_ExpressionLevel2(ISerializationContext context, ExpressionModulo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MODULO__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MODULO__LEFT));
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MODULO__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MODULO__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel2Access().getExpressionModuloLeftAction_1_4_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel2Access().getRightExpressionLevel3ParserRuleCall_1_4_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns ExpressionMultiply
	 *     ExpressionLevel1 returns ExpressionMultiply
	 *     ExpressionLevel1.ExpressionAddition_1_0_0 returns ExpressionMultiply
	 *     ExpressionLevel1.ExpressionSubtraction_1_1_0 returns ExpressionMultiply
	 *     ExpressionLevel2 returns ExpressionMultiply
	 *     ExpressionLevel2.ExpressionMultiply_1_0_0 returns ExpressionMultiply
	 *     ExpressionLevel2.ExpressionDivision_1_1_0 returns ExpressionMultiply
	 *     ExpressionLevel2.ExpressionMaximum_1_2_0 returns ExpressionMultiply
	 *     ExpressionLevel2.ExpressionMinimum_1_3_0 returns ExpressionMultiply
	 *     ExpressionLevel2.ExpressionModulo_1_4_0 returns ExpressionMultiply
	 *
	 * Constraint:
	 *     (left=ExpressionLevel2_ExpressionMultiply_1_0_0 right=ExpressionLevel3)
	 */
	protected void sequence_ExpressionLevel2(ISerializationContext context, ExpressionMultiply semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MULTIPLY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MULTIPLY__LEFT));
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MULTIPLY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MULTIPLY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel2Access().getExpressionMultiplyLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel2Access().getRightExpressionLevel3ParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns ExpressionPower
	 *     ExpressionLevel1 returns ExpressionPower
	 *     ExpressionLevel1.ExpressionAddition_1_0_0 returns ExpressionPower
	 *     ExpressionLevel1.ExpressionSubtraction_1_1_0 returns ExpressionPower
	 *     ExpressionLevel2 returns ExpressionPower
	 *     ExpressionLevel2.ExpressionMultiply_1_0_0 returns ExpressionPower
	 *     ExpressionLevel2.ExpressionDivision_1_1_0 returns ExpressionPower
	 *     ExpressionLevel2.ExpressionMaximum_1_2_0 returns ExpressionPower
	 *     ExpressionLevel2.ExpressionMinimum_1_3_0 returns ExpressionPower
	 *     ExpressionLevel2.ExpressionModulo_1_4_0 returns ExpressionPower
	 *     ExpressionLevel3 returns ExpressionPower
	 *
	 * Constraint:
	 *     (left=ExpressionLevel3_ExpressionPower_1_0 right=ExpressionLevel3)
	 */
	protected void sequence_ExpressionLevel3(ISerializationContext context, ExpressionPower semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_POWER__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_POWER__LEFT));
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_POWER__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_POWER__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel3Access().getExpressionPowerLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel3Access().getRightExpressionLevel3ParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns IntExpression
	 *     ExpressionLevel1 returns IntExpression
	 *     ExpressionLevel1.ExpressionAddition_1_0_0 returns IntExpression
	 *     ExpressionLevel1.ExpressionSubtraction_1_1_0 returns IntExpression
	 *     ExpressionLevel2 returns IntExpression
	 *     ExpressionLevel2.ExpressionMultiply_1_0_0 returns IntExpression
	 *     ExpressionLevel2.ExpressionDivision_1_1_0 returns IntExpression
	 *     ExpressionLevel2.ExpressionMaximum_1_2_0 returns IntExpression
	 *     ExpressionLevel2.ExpressionMinimum_1_3_0 returns IntExpression
	 *     ExpressionLevel2.ExpressionModulo_1_4_0 returns IntExpression
	 *     ExpressionLevel3 returns IntExpression
	 *     ExpressionLevel3.ExpressionPower_1_0 returns IntExpression
	 *     ExpressionLevel4 returns IntExpression
	 *     ExpressionLevel5 returns IntExpression
	 *
	 * Constraint:
	 *     metric=Metric
	 */
	protected void sequence_ExpressionLevel5(ISerializationContext context, IntExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.INT_EXPRESSION__METRIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.INT_EXPRESSION__METRIC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel5Access().getMetricMetricEnumRuleCall_2_0(), semanticObject.getMetric());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns ExpressionMinus
	 *     ExpressionLevel1 returns ExpressionMinus
	 *     ExpressionLevel1.ExpressionAddition_1_0_0 returns ExpressionMinus
	 *     ExpressionLevel1.ExpressionSubtraction_1_1_0 returns ExpressionMinus
	 *     ExpressionLevel2 returns ExpressionMinus
	 *     ExpressionLevel2.ExpressionMultiply_1_0_0 returns ExpressionMinus
	 *     ExpressionLevel2.ExpressionDivision_1_1_0 returns ExpressionMinus
	 *     ExpressionLevel2.ExpressionMaximum_1_2_0 returns ExpressionMinus
	 *     ExpressionLevel2.ExpressionMinimum_1_3_0 returns ExpressionMinus
	 *     ExpressionLevel2.ExpressionModulo_1_4_0 returns ExpressionMinus
	 *     ExpressionLevel3 returns ExpressionMinus
	 *     ExpressionLevel3.ExpressionPower_1_0 returns ExpressionMinus
	 *     ExpressionLevel4 returns ExpressionMinus
	 *     ExpressionMinus returns ExpressionMinus
	 *
	 * Constraint:
	 *     sub=ExpressionLevel5
	 */
	protected void sequence_ExpressionMinus(ISerializationContext context, ExpressionMinus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MINUS__SUB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_MINUS__SUB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionMinusAccess().getSubExpressionLevel5ParserRuleCall_1_0(), semanticObject.getSub());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns ExpressionPlus
	 *     ExpressionLevel1 returns ExpressionPlus
	 *     ExpressionLevel1.ExpressionAddition_1_0_0 returns ExpressionPlus
	 *     ExpressionLevel1.ExpressionSubtraction_1_1_0 returns ExpressionPlus
	 *     ExpressionLevel2 returns ExpressionPlus
	 *     ExpressionLevel2.ExpressionMultiply_1_0_0 returns ExpressionPlus
	 *     ExpressionLevel2.ExpressionDivision_1_1_0 returns ExpressionPlus
	 *     ExpressionLevel2.ExpressionMaximum_1_2_0 returns ExpressionPlus
	 *     ExpressionLevel2.ExpressionMinimum_1_3_0 returns ExpressionPlus
	 *     ExpressionLevel2.ExpressionModulo_1_4_0 returns ExpressionPlus
	 *     ExpressionLevel3 returns ExpressionPlus
	 *     ExpressionLevel3.ExpressionPower_1_0 returns ExpressionPlus
	 *     ExpressionLevel4 returns ExpressionPlus
	 *     ExpressionPlus returns ExpressionPlus
	 *
	 * Constraint:
	 *     sub=ExpressionLevel5
	 */
	protected void sequence_ExpressionPlus(ISerializationContext context, ExpressionPlus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_PLUS__SUB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.EXPRESSION_PLUS__SUB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionPlusAccess().getSubExpressionLevel5ParserRuleCall_1_0(), semanticObject.getSub());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Match returns Match
	 *
	 * Constraint:
	 *     target=MatchTarget
	 */
	protected void sequence_Match(ISerializationContext context, Match semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.MATCH__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.MATCH__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMatchAccess().getTargetMatchTargetEnumRuleCall_1_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MetricExpr returns MetricExpr
	 *
	 * Constraint:
	 *     (amount=INT metric=SizeMetric)
	 */
	protected void sequence_MetricExpr(ISerializationContext context, MetricExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.METRIC_EXPR__AMOUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.METRIC_EXPR__AMOUNT));
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.METRIC_EXPR__METRIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.METRIC_EXPR__METRIC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMetricExprAccess().getAmountINTTerminalRuleCall_0_0(), semanticObject.getAmount());
		feeder.accept(grammarAccess.getMetricExprAccess().getMetricSizeMetricEnumRuleCall_1_0(), semanticObject.getMetric());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MinSize returns MinSize
	 *
	 * Constraint:
	 *     ((expr=MetricExpr | brackets=MinSize) (operator=BoolOperator size=MinSize)?)
	 */
	protected void sequence_MinSize(ISerializationContext context, MinSize semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Node
	 *
	 * Constraint:
	 *     (name=ID | (name=ID under=Under node=Node))?
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Exclude returns Nodes
	 *     Nodes returns Nodes
	 *     DoNotCompare returns Nodes
	 *
	 * Constraint:
	 *     (node=Node nodes=Nodes?)
	 */
	protected void sequence_Nodes(ISerializationContext context, Nodes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns NotExpression
	 *     BooleanExpressionLevel1 returns NotExpression
	 *     BooleanExpressionLevel1.ExpressionBinOp_1_0 returns NotExpression
	 *     BooleanExpressionLevel2 returns NotExpression
	 *     NotExpression returns NotExpression
	 *
	 * Constraint:
	 *     sub=BooleanExpressionLevel3
	 */
	protected void sequence_NotExpression(ISerializationContext context, NotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.NOT_EXPRESSION__SUB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.NOT_EXPRESSION__SUB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotExpressionAccess().getSubBooleanExpressionLevel3ParserRuleCall_1_0(), semanticObject.getSub());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Project returns Project
	 *
	 * Constraint:
	 *     path=STRING
	 */
	protected void sequence_Project(ISerializationContext context, Project semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CloneDetectionDSLPackage.Literals.PROJECT__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CloneDetectionDSLPackage.Literals.PROJECT__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProjectAccess().getPathSTRINGTerminalRuleCall_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SearchRoot returns SearchRoot
	 *
	 * Constraint:
	 *     (nodes=Nodes condition=ComparisonExpression?)
	 */
	protected void sequence_SearchRoot(ISerializationContext context, SearchRoot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
